#user/bin/python3
import numpy as np
import linecache

#####################################################################################################
#               Calculate bond length from VASP MD                                                  #
#  1. This code is suggested to be used after MSDVASP.py and the POSCAR should be in the directory; #
#  2. The variables you should modify is 'file1','file2','atom1','atom2','rmax' and 'dr'. file1 and #
#     and file2 are the position file of selected atoms which are generated by MSDVASP.py code.     #
#     atom1 and atom2 are the atoms you selected will be calculated the bond of atom1-atom2. rmax is#
#     the max value of r calculated g(r). dr is the step interval of r.                             #
#####################################################################################################


file1, file2 = 'Cl.pos', 'O.pos'
atom1, atom2 = 'Cl', 'O'
rmax = 10
dr = 0.1
nomp = int(rmax/dr)

grout, grnout = [], []
pi = 3.1415926535897932385
alatx = linecache.getline('POSCAR', 3).strip(' ').split()
alat = float(alatx[0]); v = alat**3
species = linecache.getline('POSCAR', 6).strip(' ').split()
num_species = linecache.getline('POSCAR', 7).strip(' ').split()
if atom1 not in species or atom2 not in species:
  print("Error, the atom you selected is not in the system!")
  exit()
site1, site2 = species.index(atom1), species.index(atom2)
num1, num2 = int(num_species[site1]), int(num_species[site2])
pos1, pos2 = [], []
rho = num2/v
print(atom1+': '+str(num1)+'; '+atom2+': '+str(num2))

with open(file1) as file:
  for line in file:
    ll = line.strip(' ').split()
    pos1.append(list(map(float, ll[1:])))

with open(file2) as file:
  for line in file:
    ll = line.strip(' ').split()
    pos2.append(list(map(float, ll[1:])))

num_conf1, num_conf2 = int(len(pos1)/num1), int(len(pos2)/num2)
print(str(num_conf1)+'; '+str(num_conf2))
if num_conf1 != num_conf2:
  print("Error, these two species give different number of configurations!")
  exit()

tr_ma = []
for i in (-1, 0, 1):
  for j in (-1, 0, 1):
    for k in (-1, 0, 1):
      tr_ma.append(np.array([[i,0,0],[0,j,0],[0,0,k]]))

def supcell(position,ca):
  array = position
  base_matrix = np.array([[ca,ca,ca]]*len(array))
  new_position = []
  for mi in tr_ma:
    new_pos = array+np.dot(base_matrix, mi)
    new_position = new_position + new_pos.tolist()
  return np.array(new_position)

def calbond(aposition, bposition):
  lb = len(bposition) 
  aposition1 = [aposition]*lb
  arraya = np.array(aposition1)
  arrayb = np.array(bposition)
  bond0 = (arrayb-arraya).tolist()
  bond1 = supcell(bond0, alat)
  bond2 = np.sqrt(np.sum(bond1**2, axis=1))
  bond_len = sorted(bond2.tolist())
  return bond_len

def rdf(bdre):
    bondlength = bdre
    no = 0
    counter = [0 for i in range(nomp+1)]
    counter1 = [0 for i in range(nomp+1)]
    for b in bondlength:
        if b >= rmax+dr:
            break
        else:
            no = no + 1
            ind = int(b/dr)
            if ind == 0:
                dv = 4/3*pi*(dr**3)
            else:
                dv = 4*pi*((ind*dr)**2)*dr
        counter[ind]+=1/dv
        counter1[ind] = no
#   rho = no/(4/3*pi*(rmax**3))
    gr = (np.array(counter[:])/rho).tolist()
    for i in range(1,len(counter1)):
        if counter1[i] == 0:
            counter1[i] = counter1[i-1]
    grn = counter1[:]
#   print(grn)
    return gr, grn

for x in range(1, num_conf1+1):
    if x%100 == 0:
      print(x)
    df, dfn = [], []
    for p1 in pos1[(x-1)*num1:x*num1]:
        bd = calbond(p1, pos2[(x-1)*num2:x*num2])
        grr, grrn = rdf(bd)
        df.append(grr); dfn.append(grrn)
    df = np.mean(df, axis=0)
    dfn = np.mean(dfn, axis=0)
    grout.append(df.tolist()); grnout.append(dfn.tolist())
        
agrout = np.mean(grout, axis=0)
agrnout = np.mean(grnout, axis=0)
print(np.shape(agrout))
ofile = 'gr('+atom1+'-'+atom2+').out'
with open(ofile, "w") as wfe:
    wfe.write("r/A       gr         grn\n")
    for j in range(nomp+1):
      wfe.write(str(j*dr)+" "+str(agrout[j])+" "+str(agrnout[j]))
      wfe.write("\n")
